// Includes --------------------------------------------------------------------
#include "twi.h"

// Typedef ---------------------------------------------------------------------
// Тип состояния на шине i2c
typedef enum
{
    LINE_START        = 0x08,  // Сформировано состояние СТАРТ
    LINE_REP_START    = 0x10,  // Сформировано состояние ПОВСТАРТ
    LINE_TX_SLA_ACK   = 0x18,  // Передан пакет SLA+W и принято подтверждение (ACK)
    LINE_TX_SLA_NACK  = 0x20,  // Передан пакет SLA+W, а подтверждение не принято (NACK)
    LINE_TX_DATA_ACK  = 0x28,  // Передан пакет данных и принято подтверждение (ACK)
    LINE_TX_DATA_NACK = 0x30,  // Передан пакет данных, а подтверждение не принято (NACK)
    LINE_ARB_LOST     = 0x38,  // Потеря приоритета при передаче пакета адреса или данных
    LINE_RX_SLA_ACK   = 0x40,  // Передан пакет SLA+R и принято подтверждение (ACK)
    LINE_RX_SLA_NACK  = 0x48,  // Передан пакет SLA+R и принято неподтверждение (NACK)
    LINE_RX_DATA_ACK  = 0x50,  // Принят байт данных и передано подтверждение (ACK)
    LINE_RX_DATA_NACK = 0x58,  // Принят байт данных и передано неподтверждение (NACK)
    LINE_BUS_ERROR    = 0x00,  // Ошибка на шине в результате некорректного формирования
                               // состояния СТАРТ или СТОП
} StatusLine_t;

// Тип состояния модуля TWI
typedef enum
{
    TWI_NOINIT = 0,  // TWI не инициализирован
    TWI_READY,       // TWI готов к чтению/записи
    TWI_RUN_TX,      // TWI занят записью
    TWI_RUN_RX,      // TWI занят чтением
} TwiStatus_t;

// Macro -----------------------------------------------------------------------
#define LINE_FREQ 100000UL  // Частота обмена в Гц

// Variables -------------------------------------------------------------------
static uint8_t twiSlaW    = {0};  // Адрес ведомого устройства: SLA+W
static uint8_t twiRegAddr = {0};  // Адрес начального регистра для чтения/записи

static TwiStatus_t twiStatus = TWI_NOINIT;  // Состояние модуля TWI

static uint8_t* pbufTwi;     // Указатель на буфер для чтения/записи
static uint8_t  bufSizeTwi;  // Размер буфера для чтения/записи

// Functions -------------------------------------------------------------------
/*******************************************************************************
Функция инициализации модуля TWI
По окончанию инициализации устанавливается статус TWI_READY
Частота обмена в Гц: LINE_FREQ
Используется прерывание по событиям на шине i2c
*******************************************************************************/
void TwiInit(void)
{
    // Установка коэффициента деления для генератора тактового сигнала и
    // разрешение работы модуля TWI и прерывания по событиям на шине
    TWBR = (F_CPU / LINE_FREQ - 16) / 2;
    TWCR |= (1 << TWEN) | (1 << TWIE);

    // Установка статуса TWI_READY
    twiStatus = TWI_READY;
}

/*******************************************************************************
Функция записи данных в ведомое устройство
Во время записи устанавливается статус TWI_RUN_TX, после завершения записи 
устанавливается статус TWI_READY

Аргументы:
slaw        адрес ведомого устройства: SLA+W
regAddr     адрес начального регистра для записи
pbuf        указатель на буфер для записи
bufSize     размер буфера для записи
*******************************************************************************/
void TwiWrite(uint8_t slaw, uint8_t regAddr, uint8_t* pbuf, uint8_t bufSize)
{
    // Если статус модуля не равен TWI_READY, то выходим из функции
    if (twiStatus != TWI_READY)
    {
        return;
    }
    // Установка статуса TWI_RUN_TX
    twiStatus = TWI_RUN_TX;

    // Установка адреса ведомого устройства, адреса начального регистра для
    // записи, указателя и размера буфера  для записи
    twiSlaW    = slaw;
    twiRegAddr = regAddr;
    pbufTwi    = pbuf;
    bufSizeTwi = bufSize;

    // Формирование состояние СТАРТ на шине TWI, запуск конечного автомата
    // для записи данных
    TWCR |= (1 << TWSTA);
}

/*******************************************************************************
Функция чтения данных из ведомое устройство
Во время записи устанавливается статус TWI_RUN_RX, после завершения записи 
устанавливается статус TWI_READY

Аргументы:
slaw        адрес ведомого устройства: SLA+W
regAddr     адрес начального регистра для чтения
pbuf        указатель на буфер для чтения
bufSize     размер буфера для чтения
*******************************************************************************/
void TwiRead(uint8_t slaw, uint8_t regAddr, uint8_t* pbuf, uint8_t bufSize)
{
    // Если статус модуля не равен TWI_READY, то выходим из функции
    if (twiStatus != TWI_READY)
    {
        return;
    }
    // Установка статуса TWI_RUN_RX
    twiStatus = TWI_RUN_RX;

    // Установка адреса ведомого устройства, адреса начального регистра для
    // записи, указателя и размера буфера для чтения
    twiSlaW    = slaw;
    twiRegAddr = regAddr;
    pbufTwi    = pbuf;
    bufSizeTwi = bufSize;

    // Формирование состояние СТАРТ на шине TWI, запуск конечного автомата
    // для чтения данных
    TWCR |= (1 << TWSTA);
}

/*******************************************************************************
Функция обработки события на шине i2c
При каждом вызове, aункция анализирует текущее состояние шины i2c и выполняет
необходимые действия для перехода в новое состояние конечного автомата модуля TWI.

Возвращаемое значение:
flag        переменная с флагами завершения операций
flag.rxc    флаг завершения чтения
flag.txc    флаг завершения записи
*******************************************************************************/
TwiFlags_t TwiTwsi(void)
{
    TwiFlags_t  flag   = {0};        // Переменная с флагами завершения операций
    TwiStatus_t status = twiStatus;  // Состояние модуля TWI

    // Считывание текущего состояния шины i2c и в зависимости от него
    // выполнение необходимых действий для перехода в новое состояние
    StatusLine_t statusLine = TWSR & 0xF8;
    switch (statusLine)
    {
        case LINE_BUS_ERROR:
            // Формирование состояния СТОП
            TWCR |= (1 << TWSTO);
            break;
        case LINE_START:
            // Передача пакета SLA+W и сброс флага TWSTA
            TWDR = twiSlaW;
            TWCR &= ~(1 << TWSTA);
            break;
        case LINE_REP_START:
            // Передача пакета SLA+R и сброс флага TWSTA
            TWDR = twiSlaW + 1;
            TWCR &= ~(1 << TWSTA);
            break;
        case LINE_TX_SLA_ACK:
            // Передача байта данных с адресом регистра ведомого устройства
            // из/в которого будем считывать/записывать данные
            TWDR = twiRegAddr;
            break;
        case LINE_TX_SLA_NACK:
            // Завершение передачи: формирование состояния СТОП и установка
            // состояния TWI_READY
            TWCR |= (1 << TWSTO);
            status = TWI_READY;
            break;
        case LINE_TX_DATA_ACK:
            // В зависимости от состояния модуля TWI, переходим к считыванию
            // данных или записи данных в ведомое устройство
            switch (status)
            {
                case TWI_RUN_RX:
                    // Формирования состояния ПОВСТАРТ для считывания данных
                    TWCR |= (1 << TWSTA);
                    break;
                case TWI_RUN_TX:
                    // Передача байта данных в ведомое устройство из буфера,
                    // инкремент указателя и уменьшение размера буфера передачи.
                    // Если размер буфера равен нулю, то завершаем передачу:
                    // формируем состояние СТОП, устанавливаем состояние
                    // TWI_READY и флаг txc
                    TWDR = *pbufTwi++;
                    bufSizeTwi--;
                    if (!bufSizeTwi)
                    {
                        TWCR |= (1 << TWSTO);
                        status   = TWI_READY;
                        flag.txc = 1;
                    }
                    break;
                default:
                    break;
            }
            break;
        case LINE_TX_DATA_NACK:
            // Завершение передачи: формирование состояния СТОП, установка
            // состояние TWI_READY
            TWCR |= (1 << TWSTO);
            status = TWI_READY;
            break;
        case LINE_ARB_LOST:
            break;
        case LINE_RX_SLA_ACK:
            // Уменьшение размера буфера чтения
            // Если считываем только один байт, то сразу передаем
            // неподтверждение (NACK); иначе передаем подтверждение (ACK)
            bufSizeTwi--;
            if (bufSizeTwi)
            {
                TWCR |= (1 << TWEA);
            }
            else
            {
                TWCR &= ~(1 << TWEA);
            }
            break;
        case LINE_RX_SLA_NACK:
            // Завершение чтения: формирование состояния СТОП, установка
            // состояние TWI_READY
            TWCR |= (1 << TWSTO);
            status = TWI_READY;
            break;
        case LINE_RX_DATA_ACK:
            // Запись принятого байта данных в буфер чтения инкремент указателя,
            // и уменьшение размера буфера чтения
            // Если остался последний байт для чтения, то передаем
            // неподтверждение (NACK); иначе передаем подтверждение(ACK)
            *pbufTwi++ = TWDR;
            bufSizeTwi--;
            if (bufSizeTwi)
            {
                TWCR |= (1 << TWEA);
            }
            else
            {
                TWCR &= ~(1 << TWEA);
            }
            break;
        case LINE_RX_DATA_NACK:
            // Запись последнего принятого байта данных в буфер чтения и
            // завершение чтения: формирование состояния СТОП, установка
            // состояния TWI_READY и флага txc
            *pbufTwi++ = TWDR;
            TWCR |= (1 << TWSTO);
            status   = TWI_READY;
            flag.rxc = 1;
            break;
        default:
            // Формирование состояния СТОП и установка состояния TWI_READY
            TWCR |= (1 << TWSTO);
            status = TWI_READY;
            break;
    }
    // Сброс флага TWINT, сохранение состояния модуля TWI
    TWCR |= (1 << TWINT);
    twiStatus = status;
    // Возвращение переменной с флагами завершения операций
    return flag;
}
// End File --------------------------------------------------------------------