// Includes --------------------------------------------------------------------
#include "semseg.h"
#include <avr/pgmspace.h>

// Private Macro ---------------------------------------------------------------
#define DATA_PORT PORTC  // Порт данных к которому подключены
#define DATA_DDR  DDRC   // семисегментные индикаторы.

#define CTRL_PORT PORTB  // Управляющий порт к которому подключены общие
#define CTRL_DDR  DDRB   // катоды/аноды семисегментных индикаторов
#define CTRL_PIN3 3      // Номер вывода общего а/к четвертого индикатора
#define CTRL_PIN2 2      // Номер вывода общего а/к третьего индикатора
#define CTRL_PIN1 1      // Номер вывода общего а/к второго индикатора
#define CTRL_PIN0 0      // Номер вывода общего а/к четвертого индикатора

#define CTRL_PIN_MASK ((1 << CTRL_PIN3) | (1 << CTRL_PIN2) | \
                       (1 << CTRL_PIN1) | (1 << CTRL_PIN0))

// Private Constants -----------------------------------------------------------
// Таблица перекодировки символов в памяти программ
const uint8_t tableDecoder[10] PROGMEM = {
    0b11111100,   // код "0"
    0b01100000,   // код "1"
    0b11011010,   // код "2"
    0b11110010,   // код "3"
    0b01100110,   // код "4"
    0b10110110,   // код "5"
    0b10111110,   // код "6"
    0b11100000,   // код "7"
    0b11111110,   // код "8"
    0b11110110};  // код "9"

// Functions -------------------------------------------------------------------
/*******************************************************************************
Функция инициализации 4-х семисегментных индикаторов
Выводы данных подключены к DATA_PORT
Выводы управления подключены к CTRL_PORT
*******************************************************************************/
void SemsegInit(void)
{
    // Инициализация выводов подключенных к индикаторам
    DATA_DDR  = 0xFF;
    DATA_PORT = 0x00;
    CTRL_DDR |= CTRL_PIN_MASK;
    CTRL_PORT &= ~CTRL_PIN_MASK;
    // Включение первого индикатора
    CTRL_PORT |= (1 << CTRL_PIN0);
}

/*******************************************************************************
Функция перевода 2-х байтного числа в 4-х разрядное двоично-десятичное число.

Аргументы:
data:   исходное 2-байтное число
buf:    указатель на 4-х байтный буфер, в который записывается преобразованное
        4-х разрядное двоично-десятичное число.
bufSize: размер буфера, должен строго равняться 4
*******************************************************************************/
void SemsegBin2Bcd(uint16_t data, uint8_t* pbuf, uint8_t bufSize)
{
    if (bufSize != 4)
    {
        return;
    }

    pbuf += bufSize - 1;  // Установка указателя буфера на последний (старший)
                          // элемент

    *pbuf-- = data / 1000;  // Вычисление 4 разряда двоично-десятичного числа
    data %= 1000;           //
    *pbuf-- = data / 100;   // Вычисление 3 разряда двоично-десятичного числа
    data %= 100;            //
    *pbuf-- = data / 10;    // Вычисление 2 разряда двоично-десятичного числа
    data %= 10;             //
    *pbuf-- = data / 1;     // Вычисление 1 разряда двоично-десятичного числа
    data %= 1;
}

/*******************************************************************************
Функция отображения 4-х разрядного двоично-десятичного числа на 4-х
семисегментных индикаторах.

Аргументы:
buf:    указатель на 4-х байтный буфер, в котором расположено
        4-х разрядное двоично-десятичное число.
bufSize: размер буфера, должен строго равняться 4
*******************************************************************************/
void SemsegDisp(uint8_t* buf, uint8_t bufSize)
{
    if (bufSize != 4)
    {
        return;
    }

    uint8_t ind = 0;  // Переменная для хранения разряда числа

    DATA_PORT = 0x00;  // Выключение отображения на семисегментных индикаторах

    if (CTRL_PORT & (1 << CTRL_PIN3))    // Если активен 4-й индикатор,
    {                                    // то его выключаем,
        CTRL_PORT &= ~(1 << CTRL_PIN3);  // включаем 1-й индикатор,
        CTRL_PORT |= (1 << CTRL_PIN0);   // в ind записываем 1-й разряд
        ind = buf[0];                    // двоично-десятичного числа
    }
    else if (CTRL_PORT & (1 << CTRL_PIN0))  // Если активен 1-й индикатор,
    {                                       // то его выключаем,
        CTRL_PORT &= ~(1 << CTRL_PIN0);     // включаем 2-й индикатор,
        CTRL_PORT |= (1 << CTRL_PIN1);      // в ind записываем 2-й разряд
        ind = buf[1];                       // двоично-десятичного числа
    }
    else if (CTRL_PORT & (1 << CTRL_PIN1))  // Если активен 2-й индикатор,
    {                                       // то его выключаем,
        CTRL_PORT &= ~(1 << CTRL_PIN1);     // включаем 3-й индикатор,
        CTRL_PORT |= (1 << CTRL_PIN2);      // в ind записываем 3-й разряд
        ind = buf[2];                       // двоично-десятичного числа
    }
    else if (CTRL_PORT & (1 << CTRL_PIN2))  // Если активен 3-й индикатор,
    {                                       // то его выключаем,
        CTRL_PORT &= ~(1 << CTRL_PIN2);     // включаем 4-й индикатор,
        CTRL_PORT |= (1 << CTRL_PIN3);      // в ind записываем 4-й разряд
        ind = buf[3];                       // двоично-десятичного числа
    }
    else
    {            // Если ни один из индикаторов, не активен,
        return;  //то выходим из функции
    }

    // Выодим в порт данных семисегментного индикатора значение разряда
    // двоично-десятичного числа, который храниться в ind,
    // используя таблицу перекодировки символов tableDecoder
    uint8_t temp = pgm_read_byte(&tableDecoder[ind]);
    DATA_PORT    = temp;
}

/*******************************************************************************
Функция выключения семисегментных индикаторов
*******************************************************************************/
void SemsegOff(void)
{
    DATA_PORT = 0x00;
}
// End File --------------------------------------------------------------------