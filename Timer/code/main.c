/*******************************************************************************
Target:  Counter
Device:  ATmega16;
Board:   EasyAVR6;
Clock:   ext.clock 8 MHz

Формирует «бегущий огонек» на светодиодах, подключенных к порту А. При нажатии
на кнопку PD6/PD7 скорость «бегущего огонька» плавно увеличивается/уменьшается. 
При нажатии на кнопку PD5 изменяется направление «бегущего огонька».
Формирует ШИМ сигнал на выводе OC1B(PD4) с частотой 4 кГц. При нажатии на кнопку 
PD0/PD1 коэффициент заполнения kd плавно увеличивается/уменьшается.
Текущее значение коэффициент заполнения kd отображается на семисегментных
индикаторах, которые подключены к портам B и С.
*******************************************************************************/

// Includes --------------------------------------------------------------------
#include "main.h"
#include <avr/interrupt.h>

#include "semseg.h"  // Заголовочный файл для работы с семисегментными индикаторами
#include "timer.h"

// Variables -------------------------------------------------------------------
Flags_t flag   = {0};  // Переменная пользовательских флагов
uint8_t buf[4] = {0};  // Буфер для хранения 4-х разрядного числа для
                       // вывода на семисегментные индикаторы

// Functions -------------------------------------------------------------------
int main(void)
{
    /* Инициализация портов
    PA0...PA7 - выходы (к ним подключены светодиоды, зажигаем светодиод PA3)
    PD0...PD1, PD5...PD7 - входы c PullUp (к ним подключены кнопки)
    */
    DDRA  = 0xFF;
    PORTA = (1 << PA3);

    PORTD |= (1 << PD7) | (1 << PD6) | (1 << PD5) | (1 << PD1) | (1 << PD0);

    /* Инициализация таймера Т0 в режиме Normal с предделителем 64, TOP = 0xFF
    Используется прерывание по переполнению
    ОС0(PB3) не подключен
    Время переполнения:
    t = 256 * 64 / 8e6 = 2.048 мс, f = 8e6 / 64 / 256 = 488 Гц
    */
    TIMSK |= (1 << TOIE0);              // Разрешаем прерывание по переполнению
    TCCR0 = (1 << CS01) | (1 << CS00);  // Задаем режим и включаем таймер

    /* Инициализация таймера Т1 в режиме Fast PWM с предделителем 8, TOP = 0x00FF
    ОС1A(PD5) не подключен
    ОС1B(PD4) сбрасываем в момент совпадения, устанавливаем при переполнении
    kd = OCR1B / (TOP + 1) * 100 %    
    Время переполнения:
    t = 256 * 8 / 8e6 = 256 мкс; f = 8e6 / 8 / 256 = 4 кГц
    */
    DDRD |= DDD4;  // Настраиваем PD4 как выход

    OCR1BL = 4 * (0xFF + 1) / 100;  // Задаем значение в OCR1B, так чтобы kd = 4%

    TCCR1A = (1 << COM1B1) | (1 << WGM10);  // Задаем режим и включаем таймер
    TCCR1B = (1 << WGM12) | (1 << CS11);

    /* Инициализация таймера Т2 в режиме Normal с предделителем 1024, TOP = 0xFF
    Используется прерывание по переполнению
    ОС2(PD7) не подключен    
    Время переполнения:
    t = 256 * 1024 / 8e6 = 32.768 мс; f = 8e6 / 1024 / 256 = 30 Гц
    */
    TIMSK |= (1 << TOIE2);  // Разрешаем прерывание по переполнению
    // Задаем режим и включаем таймер
    TCCR2 = (1 << CS22) | (1 << CS21) | (1 << CS20);

    // Инициализация программного таймера в режиме СТС, timerOcr = 0xFF
    TimerInit(0xFF);

    // Инициализация семисегментных индикаторов
    SemsegInit();

    // Разрешение глобальных прерываний
    sei();

    // Основной цикл
    while (1)
    {
    }
}
// End File --------------------------------------------------------------------