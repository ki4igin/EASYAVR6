/*******************************************************************************
Target:  Uart
Device:  ATmega16;
Board:   EasyAVR6;
Clock:   ext.clock 8 MHz

Программа осуществляет обмен по интерфейсу RS-232 с помощью модуля USART.
Основные параметры:		скорость обмена 19200 бод, 
						8 бит данных,
						1 стоп-бит,
						бит паритета – нет.
Контроллер принимает пакет данных состоящий из 4-х байт:
первые 3 байта – информационные; последний – контрольная сумма.
Нажимая кнопку PB6 можно поочередно просмотреть принятые байты на семисегментных
индикаторах, которые подключены к портам B и C. На крайнем левом индикаторе
отображается номер просматриваемого байта, на двух правых -  сам принятый байт.
При нажатии на кнопку PB7 МК передает пакет данных состоящий из 3-х байт:
1-й байт – 0х80, 2-й – текущее состояния на выводах PA0...PA7,
3-й – контрольная сумма.
*******************************************************************************/

// Includes --------------------------------------------------------------------
#include "main.h"
#include <avr/io.h>      // Заголовочный файл для работы с РВВ МК
#include <avr/sleep.h>   // Заголовочный файл для работы со спящим режимом
#include <util/delay.h>  // Заголовочный файл для работы с задержками
#include <avr/interrupt.h>

#include "semseg.h"  // Заголовочный файл для работы с семисегментными индикаторами
#include "timer.h"

// Private Macro ---------------------------------------------------------------
#define NBUF_TX 3
#define NBUF_RX 4

// Private Typedef -------------------------------------------------------------
// Тип пользовательских флагов
typedef struct
{
    uint8_t btnOn : 1;  // Флаг нажатия кнопки
    uint8_t tx : 1;
    uint8_t rx : 1;
} Flags_t;

// Private Variables -----------------------------------------------------------
uint8_t buf_tx[NBUF_TX] = {0};
uint8_t buf_rx[NBUF_RX] = {0};
uint8_t buf_data[NBUF_RX] = {0};

// Functions -------------------------------------------------------------------
int main(void)
{
    Flags_t flag = {0};

    /* Инициализация портов
    PB6...PB7 - входы с PullUp (к ним подключены кнопки)
    PA0...PA7 - входы с PullUp (к ним подключен контактный переключатель)
    */
    PORTB |= (1 << PB7) | (1 << PB6);
    PORTA = 0xFF;

    /* Инициализация таймера Т0 в режиме Normal с предделителем 64, TOP = 0xFF
    Используется прерывание по переполнению
    ОС0(PB3) не подключен
    Время переполнения:
    t = 256 * 64 / 8e6 = 2.048 мс, f = 8e6 / 64 / 256 = 488 Гц
    */
    TIMSK |= (1 << TOIE0);              // Разрешаем прерывание по переполнению
    TCCR0 = (1 << CS01) | (1 << CS00);  // Задаем режим и включаем таймер

    /* Инициализация таймера Т1 в режиме CTC с предделителем 1,
    TOP = ОСR1A = 0xD800
    Используется прерывание от блока сравнения
    ОС1A(PD5) не подключен
    ОС1B(PD4) не подключен   
    Время переполнения t = ОСR1A / 8e6 = 6.9 мс
    */
    OCR1A = 0xD800;
    TIMSK |= (1 << OCIE1A);  // Разрешаем прерывание от блока сравнения OCR1A
    TCCR1B = (1 << WGM12);   // Задаем режим таймера

    /* Инициализация таймера Т2 в режиме Normal с предделителем 256, TOP = 0xFF
    Используется прерывание по переполнению
    ОС2(PD7) не подключен    
    Время переполнения:
    t = 256 * 256 / 8e6 = 8.192 мс; f = 8e6 / 256 / 256 = 122 Гц
    */
    TIMSK |= (1 << TOIE2);  // Разрешаем прерывание по переполнению
    // Задаем режим и включаем таймер
    TCCR2 = (1 << CS22) | (1 << CS21);

    /* Инициализация UART
    Cкорость обмена 19200 бод, 8 бит данных, 1 стоп-бит, бит паритета - нет
    PD0(RXD) - вход с Pull Up, PD1(TXD) - выход    
    */
    PORTD |= (1 << PD0);  // Включаем PullUp вывода PD0

    uint16_t ubrr = F_CPU / (16 * 19200) - 1;  // Задаем значение предделителя
    UBRRH         = (uint8_t)(ubrr >> 8);      // UART для скорости 19200
    UBRRL         = (uint8_t)ubrr;

    UCSRC |= (1 << URSEL) | (1 << UCSZ0) | (1 << UCSZ1);  // Задаем режим UART
    // Разрешаем работу приемника, передатчика и прерывания по приему
    UCSRB |= (1 << RXCIE) | (1 << RXEN) | (1 << TXEN);

    // Инициализация семисегментных индикаторов
    SemsegInit();

    // Разрешение глобальных прерываний
    sei();

    // Основной цикл
    while (1)
    {
        if (flag.tx)
        {
            flag.tx   = 0;
            buf_tx[0] = 0x80;
            buf_tx[1] = PINA;
            buf_tx[2] = (uint8_t)(buf_tx[0] + buf_tx[1]);
            uartSend();
        }
        if (flag.rx)
        {
            flag.rx = 0;
            uint8_t crc = (uint8_t)(buf_rx[0] + buf_rx[1] + buf_rx[2]);
            if (buf_rx[3] == crc)
            {
                buf_data[3] = buf_rx[3];
                buf_data[2] = buf_rx[2];
                buf_data[1] = buf_rx[1];
                buf_data[0] = buf_rx[0];
            }
            
        }
    }
}
// End File --------------------------------------------------------------------