/*******************************************************************************
Target:  Uart
Device:  ATmega16;
Board:   EasyAVR6;
Clock:   ext.clock 8 MHz

Программа осуществляет обмен по интерфейсу RS-232 с помощью модуля USART.
Основные параметры:		скорость обмена 19200 бод, 
						8 бит данных,
						1 стоп-бит,
						бит паритета – нет.
Контроллер принимает пакет данных состоящий из 4-х байт:
первые 3 байта – информационные; последний – контрольная сумма.
Нажимая кнопку PB6 можно поочередно просмотреть принятые байты на семисегментных
индикаторах, которые подключены к портам B и C. На крайнем левом индикаторе
отображается номер просматриваемого байта, на двух правых -  сам принятый байт.
При нажатии на кнопку PB7 МК передает пакет данных состоящий из 3-х байт:
1-й байт – 0х80, 2-й – текущее состояния на выводах PA0...PA7,
3-й – контрольная сумма.
*******************************************************************************/

// Includes --------------------------------------------------------------------
#include "main.h"

// Variables -------------------------------------------------------------------
uint8_t bufTx[NBUF_TX]  = {0};  // Буфер передачи
uint8_t bufRx[NBUF_RX]  = {0};  // Буфер приема
uint8_t dataRx[NBUF_RX] = {0};  // Массив принятых данных

Flags_t flag = {0};  // Переменная пользовательских флагов

// Function prototypes ---------------------------------------------------------
static inline uint8_t Crc(uint8_t* pbuf, uint8_t bufSize);

// Functions -------------------------------------------------------------------
int main(void)
{
    /* Инициализация портов
    PB6...PB7 - входы с PullUp (к ним подключены кнопки)
    PA0...PA7 - входы с PullUp (к ним подключен контактный переключатель)
    */
    PORTB |= (1 << PB7) | (1 << PB6);
    PORTA = 0xFF;

    /* Инициализация таймера Т0 в режиме Normal с предделителем 64, TOP = 0xFF
    Используется прерывание по переполнению
    ОС0(PB3) не подключен
    Время переполнения:
    t = 256 * 64 / 8e6 = 2.048 мс, f = 8e6 / 64 / 256 = 488 Гц
    */
    TIMSK |= (1 << TOIE0);              // Разрешаем прерывание по переполнению
    TCCR0 = (1 << CS01) | (1 << CS00);  // Задаем режим и включаем таймер

    /* Инициализация таймера Т1 в режиме CTC с предделителем 1,
    TOP = ОСR1A = 0xD800
    Используется прерывание от блока сравнения
    ОС1A(PD5) не подключен
    ОС1B(PD4) не подключен   
    Время переполнения t = ОСR1A / 8e6 = 6.9 мс
    */
    OCR1A = 0xD800;
    TIMSK |= (1 << OCIE1A);  // Разрешаем прерывание от блока сравнения OCR1A
    TCCR1B = (1 << WGM12);   // Задаем режим таймера

    /* Инициализация таймера Т2 в режиме Normal с предделителем 256, TOP = 0xFF
    Используется прерывание по переполнению
    ОС2(PD7) не подключен    
    Время переполнения:
    t = 256 * 256 / 8e6 = 8.192 мс; f = 8e6 / 256 / 256 = 122 Гц
    */
    TIMSK |= (1 << TOIE2);  // Разрешаем прерывание по переполнению
    // Задаем режим и включаем таймер
    TCCR2 = (1 << CS22) | (1 << CS21);

    /* Инициализация UART
    Cкорость обмена 19200 бод, 8 бит данных, 1 стоп-бит, бит паритета - нет
    PD0(RXD) - вход с PullUp, PD1(TXD) - выход    
    */
    PORTD |= (1 << PD0);  // Включаем PullUp вывода PD0

    uint16_t ubrr = F_CPU / (16 * 19200UL) - 1;  // Задаем значение предделителя
    UBRRH         = (uint8_t)(ubrr >> 8);        // UART для скорости 19200
    UBRRL         = (uint8_t)ubrr;

    UCSRC |= (1 << URSEL) | (1 << UCSZ0) | (1 << UCSZ1);  // Задаем режим UART
    // Разрешаем работу приемника, передатчика и прерывания по приему
    UCSRB |= (1 << RXCIE) | (1 << RXEN) | (1 << TXEN);

    // Инициализация семисегментных индикаторов
    SemsegInit();

    // Разрешение глобальных прерываний
    sei();

    // Основной цикл
    while (1)
    {
        // Если флаг tx установлен, то инициируем передачу данных
        if (flag.tx)
        {
            flag.tx = 0;

            // Формирование буфера данных для передачи
            uint8_t* pbuf = bufTx;

            *pbuf++ = 0x80;
            *pbuf++ = PINA;
            *pbuf++ = Crc(bufTx, NBUF_TX - 1);  // Последний байт равен crc

            // Запуск передачи (включение прерывания по опустошению РВВ UDR)
            UCSRB |= (1 << UDRIE);
        }
        // Если флаг rx установлен, то обрабатываем принятые данные
        if (flag.rx)
        {
            flag.rx = 0;

            // Вычисление контрольной суммы
            uint8_t crc = Crc(bufRx, NBUF_RX - 1);

            /* Если последний байт принятыйх данных равен контрольной сумме, то
            копируем данные из буфера приема bufRx в массив данных dataRx
            */
            if (bufRx[NBUF_RX - 1] == crc)
            {
                uint8_t* pbufRx  = bufRx;
                uint8_t* pdataRx = dataRx;
                for (uint8_t i = 0; i < NBUF_RX; i++)
                {
                    *pdataRx++ = *pbufRx++;
                }
            }
        }
    }
}

// Inline Functions ------------------------------------------------------------
/*******************************************************************************
Функция вычисления контрольной суммы массива

Аргументы:
pbuf:       указатель на массив        
bufSize:    размер массив

Возвращаемое значение:
контрольная сумма
*******************************************************************************/
static inline uint8_t Crc(uint8_t* pbuf, uint8_t bufSize)
{
    uint8_t crc = 0;
    for (uint8_t i = 0; i < bufSize; i++)
    {
        crc += *pbuf++;
    }
    return crc;
}
// End File --------------------------------------------------------------------