// Includes --------------------------------------------------------------------
#include "settings.h"
#include <avr/io.h>
#include <avr/interrupt.h>

#include "main.h"
#include "semseg.h"  // Заголовочный файл для работы с семисегментными индикаторами

// Variables -------------------------------------------------------------------
uint8_t numByte = {0};  // Номер байта для отображения на индикаторах
uint8_t cntRx   = {0};  // Счетчик принятых байт

// Handlers --------------------------------------------------------------------
/*******************************************************************************
Timer2 Overflow Handler
Используется для обработки нажатия кнопок
*******************************************************************************/
ISR(TIMER2_OVF_vect)
{
    // Если нажата кнопка PВ6, то переключаем отображаемый байт принятых
    // данных на индикаторах;
    // иначе, если нажата кнопка PB7 отправляем данные по UART;
    // иначе, сбрасываем флаг нажатия кнопки
    if (!(PINB & (1 << PINB6)))
    {
        if (!flag.btnOn)
        {
            flag.btnOn = 1;

            numByte++;
            if (numByte >= NBUF_RX)
            {
                numByte = 0;
            }
        }
    }
    else if (!(PINB & (1 << PINB7)))
    {
        if (!flag.btnOn)
        {
            flag.btnOn = 1;
            flag.tx    = 1;
        }
    }
    else
    {
        flag.btnOn = 0;
    }
}

/*******************************************************************************
Timer1 CompareA Handler
Используется для формирования таймаута приема данных,
для обеспечения целостности посылки
*******************************************************************************/
ISR(TIMER1_COMPA_vect)
{
    cntRx = 0;
    TCCR1B &= ~((1 << CS12) | (1 << CS11) | (1 << CS10));
}

/*******************************************************************************
Timer0 Overflow Handler
Используется для отображения байта принятых данных на семисегметных индикаторах  
*******************************************************************************/
ISR(TIMER0_OVF_vect)
{
    uint8_t  buf[4];      // Буфер для хранения 4-х разрядного числа для
    uint8_t* pbuf = buf;  // вывода на семисегментные индикаторы

    // Считывание байта данных с номером numByte во временную переменную temp и
    // формирование 4-х разрядного числа для отображения:
    // 1 разряд: младшая часть байта принятых данных с номером numByte;
    // 2 разряд: старшая часть байта принятых данных с номером numByte;
    // 3 разряд: пустой символ;
    // 4 разряд: номер numByte
    uint8_t temp = dataRx[numByte];

    *pbuf++ = temp & 0x0F;
    *pbuf++ = temp >> 4;
    *pbuf++ = 16;  // Пустой символ
    *pbuf++ = numByte;

    // Отображение на 4-х семисегментных индикаторах 4-х разрядного числа
    // (размерность буфера для числа должна строго равняться 4)
    SemsegDisp(buf, sizeof(buf));
}

/*******************************************************************************
USART RX Complete Handler
Используется для приема пакета данных
*******************************************************************************/
ISR(USART_RXC_vect)
{
    // Если приняли первый байт, то сбрасываем счетчик таймера Т1 и включаем его
    // (формируем таймаут приема данных)
    if (!cntRx)
    {
        TCNT1 = 0;
        TCCR1B |= (1 << CS10);
    }

    // Запись принятого байта в буфер bufRx и увеличение счетчика принятых байт
    // Если счетчик принятых байт равен NBUF_RX,
    // то останавливаем таймер Т1, сбрасываем счетчик принятых байт и
    // устанавливаем флаг rx
    bufRx[cntRx] = UDR;
    cntRx++;
    if (cntRx == NBUF_RX)
    {
        TCCR1B &= ~((1 << CS12) | (1 << CS11) | (1 << CS10));
        cntRx   = 0;
        flag.rx = 1;
    }
}

/*******************************************************************************
UDR Empty Handler
Используется для передачи пакета данных
*******************************************************************************/
ISR(USART_UDRE_vect)
{
    static uint8_t cntTx;  // Счетчик переданных байт

    // Передача байта из буфера bufTx и увеличение счетчика переданных байт
    // Если счетчик переданных байт равен NBUF_TX,
    // то завершаем передачу (выключаем прерывание по опустошению РВВ UDR) и
    // сбрасываем счетчик переданных байт
    UDR = bufTx[cntTx];
    cntTx++;
    if (cntTx == NBUF_TX)
    {
        UCSRB &= ~(1 << UDRIE);
        cntTx = 0;
    }
}
// End File --------------------------------------------------------------------