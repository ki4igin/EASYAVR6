// Includes --------------------------------------------------------------------
#include "settings.h"
#include <avr/io.h>
#include <avr/interrupt.h>

#include "main.h"
#include "semseg.h"  // Заголовочный файл для работы с семисегментными индикаторами

// Variables -------------------------------------------------------------------
uint8_t numByte = {0};  // Номер байта для отображения на индикаторах
uint8_t cntRx   = {0};  // Счетчик принятых байт

// Handlers --------------------------------------------------------------------
/*******************************************************************************
Timer2 Overflow Handler
Используется для обработки нажатия кнопок
*******************************************************************************/
ISR(TIMER2_OVF_vect)
{
    /* Если нажата кнопка PВ6, то переключаем отображаемый байт принятых 
    данных на индикаторах;
    иначе, если нажата кнопка PB7 отправляем данные по UART;
    иначе, сбрасываем флаг нажатия кнопки
    */
    if (!(PINB & (1 << PINB6)))
    {
        // Если флаг btnOn установлен, то кнопка не отжата, пропускаем обработку
        if (!flag.btnOn)
        {
            flag.btnOn = 1;

            numByte++;
            if (numByte >= NBUF_RX)
            {
                numByte = 0;
            }
        }
    }
    else if (!(PINB & (1 << PINB7)))
    {
        // Если флаг btnOn установлен, то кнопка не отжата, пропускаем обработку
        if (!flag.btnOn)
        {
            flag.btnOn = 1;
            flag.tx    = 1;
        }
    }
    else
    {
        flag.btnOn = 0;
    }
}

/*******************************************************************************
Timer1 CompareA Handler
Используется для формирования таймаута приема данных,
для обеспечения целостности посылки
*******************************************************************************/
ISR(TIMER1_COMPA_vect)
{
    cntRx = 0;
    TCCR1B &= ~((1 << CS12) | (1 << CS11) | (1 << CS10));
}

/*******************************************************************************
Timer0 Overflow Handler
Используется для отображения байта принятых данных на семисегметных индикаторах

Разряды 4-х разрядного числа для вывода на семисегментные индикаторы:
1 разряд:   младшая часть байта принятых данных с номером numByte;
2 разряд:   старшая часть байта принятых данных с номером numByte;
3 разряд:   пустой символ;
4 разряд:   номер numByte    
*******************************************************************************/
ISR(TIMER0_OVF_vect)
{
    uint8_t  buf[4];      // Буфер для хранения 4-х разрядного числа для
    uint8_t* pbuf = buf;  // вывода на семисегментные индикаторы

    // Считывание байта данных с номером numByte во временную переменную temp
    uint8_t temp = dataRx[numByte];

    // Формирования 4-х разрядного числа для отображения
    *pbuf++ = temp & 0x0F;
    *pbuf++ = temp >> 4;
    *pbuf++ = 16;
    *pbuf++ = numByte;

    // Отображение на 4-х семисегментных индикаторах 4-х разрядного числа
    // (размерность буфера для числа должна строго равняться 4)
    SemsegDisp(buf, sizeof(buf));
}

/*******************************************************************************
USART RX Complete Handler
Используется для приема пакета данных
*******************************************************************************/
ISR(USART_RXC_vect)
{
    /* Если приняли первый байт, то сбрасываем счетчик таймера Т1 и включаем его
    (формируем таймаут приема данных)
    */
    if (!cntRx)
    {
        TCNT1 = 0;
        TCCR1B |= (1 << CS10);
    }

    // Запись принятого байта в буфер bufRx и увеличение счетчика принятых байт
    bufRx[cntRx] = UDR;
    cntRx++;

    /* Если счетчик принятых байт равен NBUF_RX,
    то останавливаем таймер Т1, сбрасываем счетсчие принятых байт и
    устанавливаем флаг rx
    */
    if (cntRx == NBUF_RX)
    {
        TCCR1B &= ~((1 << CS12) | (1 << CS11) | (1 << CS10));
        cntRx   = 0;
        flag.rx = 1;
    }
}

/*******************************************************************************
UDR Empty Handler
Используется для передачи пакета данных
*******************************************************************************/
ISR(USART_UDRE_vect)
{
    static uint8_t cntTx;  // Счетчик переданных байт

    // Передача байта из буфера bufTx и увеличение счетчика переданных байт
    UDR = bufTx[cntTx];
    cntTx++;

    /* Если счетчик переданных байт равен NBUF_TX,
    то завершаем передачу (выключаем прерывание по опустошению РВВ UDR) и
    сбрасываем счетчик переданных байт
    */
    if (cntTx == NBUF_TX)
    {
        UCSRB &= ~(1 << UDRIE);
        cntTx = 0;
    }
}
// End File --------------------------------------------------------------------