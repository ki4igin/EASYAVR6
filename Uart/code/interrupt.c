// Includes --------------------------------------------------------------------
#include "settings.h"
#include <avr/io.h>
#include <avr/interrupt.h>

#include "main.h"
#include "semseg.h"  // Заголовочный файл для работы с семисегментными индикаторами

// Variables -------------------------------------------------------------------
uint8_t numByte = {0};
uint8_t cntRx   = {0};

// Handlers --------------------------------------------------------------------
/*******************************************************************************
Timer2 Overflow Handler
Используется для обработки нажатия кнопок
*******************************************************************************/
ISR(TIMER2_OVF_vect)
{
    /* Если нажата кнопка PВ6, то переключаем отображаемый байт данных на
    индикаторах;
    иначе, если нажата кнопка PB7 отправляем данные по UART;
    иначе, сбрасываем флаг нажатия кнопки
    */
    if (!(PINB & (1 << PINB6)))
    {
        // Если флаг btnOn установлен, то кнопка не отжата, пропускаем обработку
        if (!flag.btnOn)
        {
            flag.btnOn = 1;
            numByte++;
            numByte = (numByte >= NBUF_RX) ? 0 : numByte;
        }
    }
    else if (!(PINB & (1 << PINB7)))
    {
        // Если флаг btnOn установлен, то кнопка не отжата, пропускаем обработку
        if (!flag.btnOn)
        {
            flag.btnOn = 1;
            flag.tx    = 1;
        }
    }
    else
    {
        flag.btnOn = 0;
    }
}

/*******************************************************************************
Timer1 CompareA Handler
*******************************************************************************/
ISR(TIMER1_COMPA_vect)
{
    cntRx = 0;
    TCCR1B &= ~((1 << CS12) | (1 << CS11) | (1 << CS10));
}

/*******************************************************************************
Timer0 Overflow Handler
*******************************************************************************/
ISR(TIMER0_OVF_vect)
{
    uint8_t  buf[4];
    uint8_t* pbuf = buf;
    uint8_t  temp = dataRx[numByte];

    *pbuf++ = temp & 0x0F;
    *pbuf++ = temp >> 4;
    *pbuf++ = 16;
    *pbuf++ = numByte;

    SemsegDisp(buf, sizeof(buf));
}

/*******************************************************************************
USART RX Complete Handler
*******************************************************************************/
ISR(USART_RXC_vect)
{
    if (!cntRx)
    {
        TCNT1 = 0;
        TCCR1B |= (1 << CS10);
    }
    bufRx[cntRx] = UDR;
    cntRx++;
    if (cntRx == NBUF_RX)
    {
        TCCR1B &= ~((1 << CS12) | (1 << CS11) | (1 << CS10));
        cntRx   = 0;
        flag.rx = 1;
    }
}

/*******************************************************************************
UDR Empty Handler
*******************************************************************************/
ISR(USART_UDRE_vect)
{
    static uint8_t cntTx;

    UDR = bufTx[cntTx];
    cntTx++;
    if (cntTx == NBUF_TX)
    {
        UCSRB &= ~(1 << UDRIE);
        cntTx = 0;
    }
}
// End File --------------------------------------------------------------------